/*
 * This Kotlin source file was generated by the Gradle 'init' task.
 */
package com.github.minigdx.gradle.plugin

import com.github.minigdx.gradle.plugin.internal.MiniGdxException
import com.github.minigdx.gradle.plugin.internal.MiniGdxException.Companion.ISSUES
import com.github.minigdx.gradle.plugin.internal.Severity
import com.github.minigdx.gradle.plugin.internal.Solution
import org.gradle.api.Plugin
import org.gradle.api.Project
import org.gradle.api.publish.PublishingExtension
import org.gradle.api.publish.maven.MavenPublication
import org.gradle.jvm.tasks.Jar
import org.jetbrains.kotlin.gradle.dsl.KotlinMultiplatformExtension
import java.io.File
import java.io.IOException
import java.net.URI

/**
 * Plugin for developers of MiniGDX project.
 *
 * It configures plugins used in the project that are commons to all projects
 * like the publication, kotlin version, ...
 */
class MiniGdxDeveloperGradlePlugin : Plugin<Project> {

    private val classLoader = MiniGdxDeveloperGradlePlugin::class.java.classLoader

    override fun apply(project: Project) {
        configureProjectVersionAndGroupId(project)
        configureProjectRepository(project)
        configureKotlinMultiplatform(project)
        configureDokka(project)
        configurePublication(project)

        // TODO: Configure android
        // TODO: Configure tasks for local deploy, ...

        configureLinter(project)
        configureMakefile(project)
        configureGithubWorkflow(project)
    }

    private fun configureProjectVersionAndGroupId(project: Project) {
        var version = project.properties["version"] ?: DEFAULT_VERSION

        if (version == "unspecified") {
            version = DEFAULT_VERSION
        }

        project.version = version
        project.group = "com.github.minigdx"
    }

    private fun configurePublication(project: Project) {
        project.apply { it.plugin("maven-publish") }
        project.afterEvaluate {
            project.extensions.configure(PublishingExtension::class.java) {
                it.publications.forEach {
                    val publication = it as? MavenPublication
                    publication?.artifact(project.tasks.getByName("javadocJar"))
                }

            }

        }
    }

    private fun configureDokka(project: Project) {
        project.apply { it.plugin("org.jetbrains.dokka") }
        project.tasks.register("javadocJar", Jar::class.java) {
            it.dependsOn(project.tasks.getByName("dokka"))
            it.archiveClassifier.set("javadoc")
            it.from(project.buildDir.resolve("dokka"))
        }
    }

    private fun configureProjectRepository(project: Project) {
        project.repositories.mavenCentral()
        project.repositories.google()
        project.repositories.mavenLocal()
    }

    private fun configureKotlinMultiplatform(project: Project) {
        project.apply { it.plugin("org.jetbrains.kotlin.multiplatform") }
        project.extensions.configure<KotlinMultiplatformExtension>("kotlin") { mpp ->
            mpp.js {
                this.useCommonJs()
                this.browser {
                    this.webpackTask {
                        this.compilation.kotlinOptions {
                            this.sourceMap = true
                            this.sourceMapEmbedSources = "always"
                        }
                    }
                }
                this.nodejs
            }

            mpp.jvm {
                this.compilations.getByName("main").kotlinOptions.jvmTarget = "1.8"
                this.compilations.getByName("test").kotlinOptions.jvmTarget = "1.8"
            }

            project.plugins.withId("com.android.library") {
                mpp.android {
                    publishLibraryVariants("release", "debug")
                }
            }

            mpp.mingwX64 {
                binaries {
                    staticLib { }
                    sharedLib { }
                }
            }
            mpp.linuxX64 {
                binaries {
                    staticLib { }
                    sharedLib { }
                }

            }
            mpp.ios {
                binaries {
                    staticLib { }
                    sharedLib { }
                }
            }
            mpp.macosX64 {
                binaries {
                    staticLib { }
                    sharedLib { }
                }
            }

            mpp.sourceSets.apply {
                getByName("commonMain") {
                    it.dependencies {
                        implementation(kotlin("stdlib-common"))
                    }
                }

                getByName("commonTest") {
                    it.dependencies {
                        implementation(kotlin("test-common"))
                        implementation(kotlin("test-annotations-common"))
                    }
                }

                getByName("jsMain") {
                    it.dependencies {
                        implementation(kotlin("stdlib-js"))
                    }
                }

                getByName("jsTest") {
                    it.dependencies {
                        implementation(kotlin("test-js"))
                    }
                }

                getByName("jvmMain") {
                    it.dependencies {
                        implementation(kotlin("stdlib-jdk8"))
                    }
                }

                getByName("jvmTest") {
                    it.dependencies {
                        implementation(kotlin("test-junit"))
                    }
                }

            }
        }
    }

    private fun configureLinter(project: Project) {
        project.apply { it.plugin("org.jlleitschuh.gradle.ktlint") }
    }

    private fun copy(project: Project, filename: String, target: File) {
        val content = classLoader.getResourceAsStream(filename) ?: throw MiniGdxException.create(
            severity = Severity.GRAVE,
            project = project,
            because = "'$filename' file not found in the plugin jar! The plugin might have been incorrectly packaged.",
            description = "The plugin is trying to copy a resource that should has been packaged into the plugin " +
                "but is not. As this file is required, the plugin will stop.",
            solutions = listOf(Solution("An issue can be reported to the developer", ISSUES))
        )
        target.resolve(File(filename).name).apply {
            println(this.absolutePath)
            if(!exists()) createNewFile()
            writeBytes(content.readBytes())
        }
    }

    private fun configureGithubWorkflow(project: Project) {
        project.rootProject.tasks.register("createGithubWorkflows") {
            it.group = "minigdx-dev"
            it.doLast {
                try {

                val target = it.project.projectDir.resolve(".github/workflows")
                if(!target.exists()) {
                    it.project.mkdir(".github/workflows")
                }
                copy(project, "github/workflows/build.yml", target)
                copy(project, "github/workflows/publish-release.yml", target)
                } catch (ex: IOException) {
                    ex.printStackTrace()
                }
            }
        }
    }

    private fun configureMakefile(project: Project) {
        project.rootProject.tasks.register("createMakefile") {
            it.group = "minigdx-dev"
            it.doLast {
                val target = it.project.projectDir
                copy(project, "Makefile", target)
            }
        }
    }

    companion object {

        private const val DEFAULT_VERSION = "DEV-SNAPSHOT"
    }
}
