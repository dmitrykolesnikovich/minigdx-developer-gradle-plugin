/*
 * This Kotlin source file was generated by the Gradle 'init' task.
 */
package com.github.minigdx.gradle.plugin

import com.github.minigdx.gradle.plugin.internal.MiniGdxException
import com.github.minigdx.gradle.plugin.internal.MiniGdxException.Companion.ISSUES
import com.github.minigdx.gradle.plugin.internal.Severity
import com.github.minigdx.gradle.plugin.internal.Solution
import org.gradle.api.Plugin
import org.gradle.api.Project
import org.gradle.api.publish.PublishingExtension
import org.gradle.api.publish.maven.MavenPublication
import org.gradle.jvm.tasks.Jar
import org.gradle.plugins.signing.SigningExtension
import java.io.File
import java.io.IOException

/**
 * Plugin for developers of MiniGDX project.
 *
 * It configures plugins used in the project that are commons to all projects
 * like the publication, kotlin version, ...
 */
class MiniGdxDeveloperPlugin : Plugin<Project> {

    private val classLoader = MiniGdxDeveloperPlugin::class.java.classLoader

    override fun apply(project: Project) {
        configureProjectVersionAndGroupId(project)
        configureProjectRepository(project)
        configureDokka(project)
        configurePublication(project)
        configureLinter(project)
        configureMakefile(project)
        configureGithubWorkflow(project)

        configureSonatype(project)
    }

    private fun configureProjectVersionAndGroupId(project: Project) {
        var version = project.properties["version"] ?: DEFAULT_VERSION

        if (version == "unspecified") {
            version = DEFAULT_VERSION
        }

        project.version = version
        project.group = "com.github.minigdx"
    }

    private fun configurePublication(project: Project) {
        project.apply { it.plugin("maven-publish") }
        project.afterEvaluate {
            project.extensions.configure(PublishingExtension::class.java) {
                it.publications.forEach {
                    val publication = it as? MavenPublication
                    publication?.artifact(project.tasks.getByName("javadocJar"))
                }

            }

        }
    }

    private fun configureDokka(project: Project) {
        project.apply { it.plugin("org.jetbrains.dokka") }
        project.tasks.register("javadocJar", Jar::class.java) {
            it.dependsOn(project.tasks.getByName("dokka"))
            it.archiveClassifier.set("javadoc")
            it.from(project.buildDir.resolve("dokka"))
        }
    }

    private fun configureProjectRepository(project: Project) {
        project.repositories.mavenCentral()
        project.repositories.google()
        project.repositories.mavenLocal()
    }

    private fun configureLinter(project: Project) {
        project.apply { it.plugin("org.jlleitschuh.gradle.ktlint") }
    }

    private fun copy(project: Project, filename: String, target: File) {
        val content = classLoader.getResourceAsStream(filename) ?: throw MiniGdxException.create(
            severity = Severity.GRAVE,
            project = project,
            because = "'$filename' file not found in the plugin jar! The plugin might have been incorrectly packaged.",
            description = "The plugin is trying to copy a resource that should has been packaged into the plugin " +
                "but is not. As this file is required, the plugin will stop.",
            solutions = listOf(Solution("An issue can be reported to the developer", ISSUES))
        )
        target.resolve(File(filename).name).apply {
            println(this.absolutePath)
            if(!exists()) createNewFile()
            writeBytes(content.readBytes())
        }
    }

    private fun configureGithubWorkflow(project: Project) {
        // The task is already registered
        if(project.rootProject.tasks.findByName("createGithubWorkflows") != null) {
            return
        }
        project.rootProject.tasks.register("createGithubWorkflows") {
            it.group = "minigdx-dev"
            it.description = "Copy default Github workflows inside this project."
            it.doLast {
                try {

                val target = it.project.projectDir.resolve(".github/workflows")
                if(!target.exists()) {
                    it.project.mkdir(".github/workflows")
                }
                copy(project, "github/workflows/build.yml", target)
                copy(project, "github/workflows/publish-release.yml", target)
                } catch (ex: IOException) {
                    ex.printStackTrace()
                }
            }
        }
    }

    private fun configureMakefile(project: Project) {
        // The task is already registered
        if(project.rootProject.tasks.findByName("createMakefile") != null) {
            return
        }
        project.rootProject.tasks.register("createMakefile") {
            it.group = "minigdx-dev"
            it.description = "Copy default Makefile inside this project."
            it.doLast {
                val target = it.project.projectDir
                copy(project, "Makefile", target)
            }
        }
    }

    private fun configureSonatype(project: Project) {
        if(project.properties["signing.base64.secretKey"] == null) {
            return
        }
        project.apply { it.plugin("org.gradle.signing") }
        project.extensions.configure(SigningExtension::class.java) {
            it.sign(project.extensions.getByType(PublishingExtension::class.java).publications)
            it.useInMemoryPgpKeys(
                project.properties["signing.base64.secretKey"].toString(),
                project.properties["signing.password"].toString()
            )
        }
    }

    companion object {

        private const val DEFAULT_VERSION = "DEV-SNAPSHOT"
    }
}
